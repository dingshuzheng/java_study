# 第五章 面向对象（中）

## 面向对象的特征之二：继承性

```
一、继承的好处：
1.减少了代码的冗余，提高了复用性
2.便于功能的扩展
3.为之后的多态性提供了前提

二、继承性的格式： class A extends B{}
    A：子类、派生类、subclass
    B：父类、超类、基类、superclass

    2.1 体现：一旦子类A继承了父类B后，子类A就获取了父类B中声明的所有的属性和方法
        特别的，父类中声明为private的属性或方法，子类继承父类以后。仍然认为获取了父类中私有的结构
        只是因为封装性的影响，使得子类不能直接调用父类的结构而已

    2.2 子类继承父类以后可以声明自己的属性和方法：实现功能的扩展
        子类和父类的关系不同于子集和集合的关系

三、Java中关于继承性的规定：
    1.一个类可以被多个类继承
    2.Java中类的单继承性：一个类只可以继承一个父类
    3.子父类是相对的概念
    4.子类直接继承的父类称为直接父类，间接继承的父类称为间接父类
    5.子类继承父类以后，就获取了直接父类以及间接父类中的声明的属性和方法

四、java.lang.object类的理解
    1.如果我们没有显式的声明一个父类的话，则此类继承于java.lang.Object类
    2.所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类
    3.意味着，所有的java类具有java.lang.Object类声明的功能
```

## 方法的重写

```
方法的重写（override/overwrite）

1.重写：子类对父类继承后，可以对父类中的同名同参数的方法，进行覆盖操作

2.应用：重写以后，当创建子类对象后，通过子类对象调用子父类中同名同参数的方法时，实际执行的是子类重写父类的方法

3.重写的规定：
    方法的声明：权限修饰符 返回值类型 方法名（形参列表）throws 异常的类型{
                //方法体
                }

    约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法

    3.1 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同

    3.2 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
        > 特殊情况：子类不能重写父类中声明为private的方法

    3.3 返回值类型：

        父类被重写的返回值类型是void，则子类的返回值类型也只能是void

        父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类

        父类被重写的方法的返回值类型是基本数据类型（比如double），则子类重写的方法的返回值类型必须是相同的基本数据类型（必须也是double）

    3.4 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时讲）
*********************************************************************************************************************************

    子类和父类中同名和同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）

面试题：区分方法的重写与重载
    重载，是指允许存在多个同名的方法，而这些方法的参数不同。编译器更具方法的不同参数列表，对同名方法的名称做修饰。
    对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，
    即子类可以重载父类的同名不同参数的方法。
    所以：对于重载而言，在方法调用之前，编译器就已确定了所要调用的方法，这称为“早绑定”或“静态绑定”
    而对于多态，只有等到方法调用那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”
```

## super关键字

```
super关键字的使用：
1.super理解为：父类的

2.super可以用来调用：属性、方法、构造器

3.super的使用:(调用属性和方法)

    3.1 子类的方法或构造器中，通过使用“super.方法”的方式，显式的调用父类中声明的属性和方法
        通常情况下，我们习惯省略“super.”

    3.2 特殊情况：当子类和父类定义了同名的属性时，我们想要在子类中调用父类中声明的属性，
        则必须使用“super.方法”的方式，表明调用的是父类中声明的属性

    3.3 特殊情况：当子类重写了父类中的方法后，我们想要在子类的方法中调用父类被重写的方法时，
        则必须使用“super.方法”的方式，表明调用的是父类中声明的方法

4.super调用构造器

    4.1 我们可以在子类的构造器中显式的使用“super(形参列表)”的方式，调用父类中声明的指定的构造器

    4.2 “super（形参列表）”的使用，必须声明在子类构造器的首行

    4.3 我们在类的构造器中，针对于“this（形参列表）”或“super（形参列表）”只能二选一

    4.4 在构造器的首行没有显式的声明“this（形参列表）”或“super（形参列表）”，
        则默认的是“super（）”即父类中空参的构造器

    4.5 在类的多个构造器中，至少有一个类的构造器使用了“super（形参列表）”，调用了父类的构造器
```

## 子类对象实例化全过程

```
子类对象实例化的全过程

1.从结果来看：
    子类继承父类以后就获取了父类中声明的属性和方法
    创建子类的对象就会在堆空间中加载父类中声明的属性

2.从过程中看：
    当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用父类的构造器，
    进而调用父类的父类的构造器，直到调用了java.lang.Object类中的空参的构造器。
    正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用

明确：虽然创建子类对象时，调用了父类的构造器，但至始至终就创建了一个对象，即为new的子类对象
```

## 面向对象的特征之三：多态性

```
面向对性的特征之三：多态性（Polymorphism）

1.理解多态性：可以理解为一个事物的多种形态;同一个方法表现出不同的行为

2.何为多态性：父类的引用指向子类的对象（子类的对象赋给父类的引用）
             也可以说是用接口类型来代表实现类对象

3.多态的使用：虚拟方法的使用
    有了对象的多态性后，我们在编译期，只能调用父类中声明的方法（此时父类中的方法被称为虚拟方法），但在运行期，实际执行的是子类重写父类的方法
    总结：编译看左，运行看右

4.多态性的使用前提：
    4.1 要有类的继承关系
    4.2 要有方法的重写

5.对象的多态性只适用于方法，不适用于属性（属性：编译和运行都看左边）

多态是运行时行为，只与方法有关

补充：
        //有了对象的多态性以后，内存中实际上是加载了子类所特有的属性和方法，但是由于变量声明为父类类型，
        //导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用

        //如何才能调用子类中的属性和方法
        //向下转型：使用强制类型转换符（向上转型即多态，父类的引用指向子类的对象的操作即为向上转型）
        Man m1 = (Man)p2;
        m1.isSmoking = true;

        //使用强转时，可能出现ClassCastException的异常
//        Woman w1 =(Woman)p2;
//        w1.goShopping();

        instanceof关键字的使用

        a instanceof A:判断对象a是否是类A的实例，如果是，返回true，如果不是，返回false

        使用情景：为了避免向下转型时出现：ClassCastException额异常，我们在向下转型之前
        进行instanceof的判断，一旦返回true，就进行向下转型，如果返回false，就不向下转型

        如果 a instanceof A返回true，则a instanceof B也返回true
        其中，类B是类A的父类
```

## Object类的使用

```
1. Object是所有Java类的根父类
2. 如果在类的声明中未使用extends关键字，则默认父类为java.lang.Object
3. Object类中额功能（属性、方法）有哪些
    属性：无
    方法：equals() / toString() / getClass() / hashCode() / clone() / finalize() / wait() / notify() / notifyAll()

4. Object只声明了一个空参的构造器
（Object其实也是数组的父类）
```

### equals()

```
面试题： == 和 equals 的区别

一、回顾 == 的使用

== ： 运算符

1. 可以使用在基本数据类型变量和引用数据类型变量当中

2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等（不一定类型要相等）
   如果比较的是引用数据类型的变量，比较的是两个对象的地址值是否相同(即两个引用是否指向同一个对象实体）

3. 补充：== 符号使用时，必须保证两边变量类型一致
二、equals（）方法的使用

1. 是一个方法，而非运算符

2. 只适用于引用数据类型

3. Object类中equals（）的定义：
    public boolean equals(Object obj) {
        return (this == obj);
    }
    说明：Object类中定义的equals（）的方法和 == 是相同的：比较两个对象的地址值是否相同

4. 像String,Date,File等包装类等都重写了Object类中的equals（）方法，重写后比较的不是两个引用的地址是否相同
   而是两个对象的“实体内容”是否相同

5. 通常情况下，我们自定义的类如果使用equals（）的话，通常是比较两个对象的实体内容是否相同，那么我们就需要
   对Object类中的equals（）方法进行重写
```

### toString()

```
Object类中toString（）的使用

1. 当我们输出一个类的对象时，实际上就是调用当前对象的toString（）
	当对象是null时，情况就不一样了
	String s = "abc";
	System.out.println(s);//null
	System.out.println(s.toString);//出现NullPointerException

2. Object类中的toString（）的定义
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }

3. 像String、Date、File、包装类都重写了Object类中的toString（）方法
   使得在调用toString（）时，返回“实体内容”信息

4. 自定义类也可以重写toString（）方法，当调用此方法时，返回对象的“实体内容”
```

## 单元测试方法

```
java中的JUnit单元测试

1. 创建Java类：此类时public 此类提供公共的无参构造器

2. 此类中声明的单元测试方法：方法权限时public，无形参，无返回值

3. 此类单元测试方法上需声明@Test，并导入：import org.junit.Test;

4.执行结果无异常，绿条；反之，红条
```

## 包装类的使用

```
包装类的使用：

1. Java提供了8中基本数据类型对应的包装类，使得基本数据类型的变量具有了类的特征

2. 掌握：基本数据类型、包装类、String三者之间的转化
	String类型 --> 基本数据类型、包装类：调用包装类的parseXxx（）
	    int num2 = Integer.parseInt(str1);
        System.out.println(num2 + 1);//124
    基本数据类型、包装类 --> String类型：调用String重载的valueOf（Xxx xxx）
    	//方式一：连接运算
        String str1 = num1 + "";
        //方式二：
        float f1 = 12.3f;
        String str2 = String.valueOf(f1);
        System.out.println(str2);//12.3

        Double d1 = new Double(12.4);
        String str3 = String.valueOf(d1);
        System.out.println(str3);//12.4
```